> Consider the problem of making change for $n$ cents using the fewest number of coins. Assume that each coin's value is an integer.
>
> **a.** Describe a greedy algorithm to make change consisting of quarters, dimes, nickels, and pennies. Prove that your algorithm yields an optimal solution.
>
> **b.** Suppose that the available coins are in the denominations that are powers of $c$, i.e., the denominations are $c^0, c^1, \ldots, c^k$ for some integers $c > 1$ and $k \ge 1$. Show that the greedy algorithm always yields an optimal solution.
>
> **c.** Give a set of coin denominations for which the greedy algorithm does not yield an optimal solution. Your set should include a penny so that there is a solution for every value of $n$.
>
> **d.** Give an $O(nk)$-time algorithm that makes change for any set of $k$ different coin denominations, assuming that one of the coins is a penny.

**a.** The algorithm for solving this real-life problem is exactly what we do in
real life, which is to always use the greatest value coins for the existing amount
and to use as many of those coins as possible without exceeding the existing
amount. After deducting this sum from the existing amount, we use the
remainder as the new existing amount and repeat the process.
This is a greedy algorithm. We apply the best solution for the current step
without regard for the optimal solution. This is usually easy to understand and
simple to implement. In the case of American currency, the greedy algorithm
provides the best solution because locally optimal solutions lead to globally
optimal solution as well.
Proof:
1. Let’s consider pennies and nickels. At most, I can use 4 pennies because any
number larger than 4 pennies would be replaced by at least 1 nickel. This
operation would reduce the total coin number by 4. In other words, when the
remainder is greater than 5 and I’m allowed to use only pennies and nickels, I
would use as many nickels as possible before considering pennies.
2. Let’s now consider pennies, nickels, and dimes. At most, I can use 1 nickel
because any number larger than 2 nickels would be replaced by at least 1 dime.
This operation would reduce the total coin number by 1. In other words,
when the remainder is greater than 10 and I’m allowed to use only pennies, 
nickels, and dimes, I would use as many dimes as possible before considering
nickels and pennies.
3. Now, let’s consider pennies, nickels, dimes, and quarters. At most, I can use 2
dimes because any number larger than 3 dimes would be replaced by 1 quarter
plus 1 nickel. This operation would reduce the total coin number by 1. In
other words, when the remainder is greater than 30, I would use as many
combinations of quarters and nickels as possible. Then, of course, the actual
amount of nickels used would fall into the second case. They would be
replaced by dimes if possible. So, the solution is to use as many quarters as
possible when the remainder is greater than 30.
4. For the gap between 25 and 30, based on the first two arguments, I would use
2 dimes, 1 nickel, and n−25 pennies. Obviously, I would use 1 quarter to
replace the 2 dimes and 1 nickel. This operation would reduce the total coin
number by 2.
Therefore, the greedy algorithm provides the optimal solution for this set of coin
denomination.

**b.** Proof:
1. The reasoning is very similar to that of the previous question. Let’s consider
the first two types of coins in this set, pennies and coins that are worth c
cents each, which we will call c&#770;. At most, we can use c−1 pennies because
any number larger than c pennies would be replaced by at least one c&#770; coin.
This operation would reduce the total coin number by c−1. In other words,
when the remainder is greater than c and I’m allowed to use only pennies and
c&#770; coins, I would use as many c&#770; coins before considering pennies.
2. The same thoughts apply for larger coins. Let’s consider c&#770;<sup>n-1</sup> and c&#770;<sup>n</sup> coins. At most, we can use c−1 c&#770;<sup>n-1</sup> coins. Because any number larger than c<sup>n</sup> would be replaced by at least one c&#770;<sup>n</sup> coin. This operation would reduce the total coin number by c−1. In other words, when the remainder is greater than c<sup>n</sup> and I’m allowed to use only coins that are worth less than c&#770;<sup>n</sup> , I would use as many c&#770;<sup>n</sup> coins as possible before considering other coins.
3. Combining the first two arguments, the greedy algorithm applies to all the
levels of this particular coin set denomination.

**c.** Let the coin denominations be $\\{1, 3, 4\\}$, and the value to make change for be $6$. The greedy solution would result in the collection of coins $\\{1, 1, 4\\}$ but the optimal solution would be $\\{3, 3\\}$.

**d.** See algorithm $\text{MAKE-CHANGE}(S, v)$ which does a dynamic programming solution. Since the first forloop runs $n$ times, and the inner for loop runs $k$ times, and the later while loop runs at most $n$ times, the total running time is $O(nk)$.
